
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Documentation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
            color: #333;
        }
        header, main {
            max-width: 800px;
            margin: auto;
            padding: 20px;
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        header h1 {
            font-size: 2em;
            margin-bottom: 0.5em;
        }
        header p {
            margin: 0;
            color: #555;
        }
        h2 {
            border-bottom: 2px solid #333;
            padding-bottom: 5px;
            margin-top: 1.5em;
        }
        ul {
            list-style: square;
            margin: 10px 0;
            padding-left: 20px;
        }
        code, pre {
            background: #f4f4f4;
            padding: 5px;
            border: 1px solid #ddd;
            font-family: Consolas, monospace;
        }
        pre {
            overflow-x: auto;
            padding: 10px;
        }
        a {
            color: #0066cc;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <header>
        <h1>API Documentation</h1>
        <p>Version: 1.0 | Last Updated: 06/12/2024</p>
        <p>Authors:  Davide Orsucci, Filippo Morelli, Hamza Karoui</p>
    </header>
    <main>
        <h2>Introduction</h2>
        <p>
            This is the documentation for the database APIs that provide access to the kpi database, and all its derivatives. 
			The full code of the implementation can be found in this github repo <a href="https://github.com/Kreative-Performative-Individuals/smart-industrial-database">link</a>. 
			A detailed reppresentation of the database can be found in the readme of the repository.
			<div style="margin-bottom: 20px;"></div>
			Below we provide a list of the main tables, as well as the methods and documentation for the API.
			<ul>
			  <li><strong>Pure KPIs</strong>:
				<ul>
				
				  <li>DESCRIZIONE DELLE TABELLE -> <code>id</code>, <code>name</code>, <code>aggregated_value</code>, <code>begin_datetime</code>,  <code>begin_datetime</code>, <code>begin_datetime</code> </li>
				  
				</ul>
			  </li>
			</ul>

        </p>

        <h2>Methods and Documentation</h2>
		
		<h3><code>get_aggregated_kpi_base(time_start: Optional[datetime] = None, time_end: Optional[datetime] = None)</code></h3>
		<p>
			<strong>Description:</strong> Returns the full aggregated_kpi table, filtered by the time constraint given.
			If one of two is missing it returns the full table.
		</p>

		<p><strong>Parameters:</strong></p>
		<ul>
		  <li><code>time_start</code> (optional, datetime): The start of the time filtering in datetime python format.</li>
		  <li><code>time_end</code> (optional, datetime): : The end of the time filtering.</li>
		</ul>


		<p><strong>Returns:</strong></p>
		<p>The function returns the table in an array of dictionary, every dicitionary is a row of the original table.</table></p>

		<h3>Examples</h3>
		<pre>
>>> Quando funziona te lo faccio vede</pre>
		
		<hr style="border: 1px solid #000000; margin: 50px auto;">
		
		<h3><code>get_machines_base(asset_id: Optional[str]=None)</code></h3>
		<p>
			<strong>Description:</strong> Retrieves machine information from the machines table. If asset_id is provided, filters the table by asset_id. Otherwise, returns the entire table.
		</p>

		<p><strong>Parameters:</strong></p>
		<ul>
		  <li><code>asset_id</code> (optional, string): The unique identifier of the machine requested.</li>
		</ul>


		<p><strong>Returns:</strong></p>
		<p>The function returns the table in an array of dictionary, every dicitionary is a row of the original table.</table></p>

		<h3>Examples</h3>
		<pre>
>>> Quando funziona te lo faccio vede</pre>

		<hr style="border: 1px solid #000000; margin: 50px auto;">
		
		<h3><code>def get_maintenance_records_base(time_start: Optional[datetime] = None, time_end: Optional[datetime] = None)</code></h3>
		<p>
		  <strong>Description:</strong> Retrieves maintenance records from the maintenance_records table filtered by the datetime range. If no parameters are provided, the entire table is returned.
		</p>

		<p><strong>Parameters:</strong></p>

		<ul>
			<li><code>time_start</code> (optional, datetime): The start of the time filtering in datetime python format.</li>
			<li><code>time_end</code> (optional, datetime): : The end of the time filtering.</li>
		</ul>

		<p><strong>Returns:</strong></p>
		<p>The function returns the table in an array of dictionary, every dicitionary is a row of the original table.</table></p>
		
		<h3>Examples</h3>
		<pre>
>>> Quando funziona te lo faccio vede</pre>


		<hr style="border: 1px solid #000000; margin: 50px auto;">
		
		<h3><code>def get_personal_data_base(name: Optional[str] = None, surname: Optional[str] = None, operator_id: Optional[int] = None):</code></h3>
		<p>
		  <strong>Description:</strong>
		  Retrieves personal data based on the given parameters from the personal_data table. If no parameters are provided, the entire table is returned.
		  It returns filtered datas if asset_id is provided, otherwise if both name and surname are provided.
		</p>

		<p><strong>Parameters:</strong></p>
		<ul>
			<li><code>name</code> (optional, string): The name of the operator .</li>
			<li><code>surname</code> (optional, string): The surname of the operator.</li>
			<li><code>operator_id</code> (optional, integer): The operator unique id.</li>
	
		</ul>

		<p><strong>Returns:</strong></p>
		<ul>
		 The function returns the table in an array of dictionary, every dicitionary is a row of the original table.
		</ul>

		<h3>Examples</h3>
		<pre>
Dopo te la metto
</pre>
		
		<hr style="border: 1px solid #000000; margin: 50px auto;">
		
		<h3><code>def get_production_logs_base(start_time: Optional[datetime] = None, end_time: Optional[datetime] = None, asset_id: Optional[str] = None)</code></h3>
		<p>
		  <strong>Description:</strong> Retrieve records from the production_logs table based on optional filters. If no parameters are provided, the entire table is returned.
		  If time_start and time_end are both provided, the table is filtered by the datetime range. If only the asset_id is provided, the table is filtered by asset_id.
		</p>

		<p><strong>Parameters:</strong></p>
		<ul>
			<li><code>time_start</code> (optional, datetime): The start of the time filtering in datetime python format.</li>
			<li><code>time_end</code> (optional, datetime): : The end of the time filtering.</li>
			<li><code>asset_id</code> (optional, string): The unique identifier of the machine which produced the logs.</li>
		</ul>


		<p><strong>Returns:</strong></p>
		<ul>
		 The function returns the table in an array of dictionary, every dicitionary is a row of the original table.
		</ul>
		<h3>Examples</h3>
		<pre>
dopoooo</pre>

		<hr style="border: 1px solid #000000; margin: 50px auto;">
		
		<h3><code>def get_real_time_data_base(start_time: Optional[datetime] = None, end_time: Optional[datetime] = None, kpi: Optional[str] = None, asset_id: Optional[str] = None)</code></h3>
		<p>
		  <strong>Description:</strong> Retrieve records from the real_time_data table based on optional filters. If no parameters are provided, the entire table is returned.
		  If time_start and time_end are both provided, the table is filtered by the datetime range. If only the asset_id is provided, the table is filtered by asset_id. 
		  If only the kpi is provided, the table is filtered by kpi. If everything is provided, the table is filtered by all the parameters. If no parameters are provided, the entire table is returned.
		</p>

		<p><strong>Parameters:</strong></p>
		<ul>
			<li><code>time_start</code> (optional, datetime): The start of the time filtering in datetime python format.</li>
			<li><code>time_end</code> (optional, datetime): : The end of the time filtering.</li>
			<li><code>kpi</code> (optional, string): Name of the kpi type.</li>
			<li><code>asset_id</code> (optional, string): The unique identifier of the machine invlolved in kpi creation.</li>
		</ul>

		<p><strong>Returns:</strong></p>
		The function returns the table in an array of dictionary, every dicitionary is a row of the original table.
		</ul>

		<h3>Examples</h3>
		<pre> DOPO TE LO BUTTO
</pre>


		<hr style="border: 1px solid #000000; margin: 50px auto;">
		
		<h3><code>DA QUI IN POI ROBE A CASO</code></h3>
		<p>
		  <strong>Description:</strong> Apply <code>get_object_properties</code> to the entity whose label is the closest match to the given label.
			The closeness is determined by a similarity measure (default is Levenshtein distance).
		</p>

		<p><strong>Parameters:</strong></p>
		<ul>
		  <li><code>owl_label</code> (str): The label of the ontology element whose closest match is to be found.</li>
		  <li><code>method</code> (str): The similarity measure to use for finding the closest match (default: 'levenshtein').</li>
		</ul>

		<p><strong>Returns:</strong></p>
		<ul>
		  <li><code>tuple</code>: A tuple containing:
			<ul>
			  <li><code>dict</code>: The properties of the closest matching element.</li>
			  <li><code>float</code>: The similarity score (between 0 and 1) of the closest match.</li>
			</ul>
		  </li>
		</ul>

		<h3>Notes</h3>
		<p>If no exact match for the given label is found, the function uses the specified similarity measure (e.g., Levenshtein distance) 
		to find the closest match in the ontology and returns its properties along with the similarity score.
		Currently only the Levenshtein distance has been implemented and changing the method will generate an error.</p>

		<h3>Examples</h3>
<pre>
>>> get_closest_object_properties('total_carbon_footprint')
({'label': 'total_carbon_footprint',
  'description': 'This KPI is a sustainability metric that measures the amount of CO2 emissions produced globally 
		for a process, machine, or system. It provides insights into the environmental impact, enabling 
		organizations to track and reduce their carbon emissions.',
  'unit_of_measure': 'CO2 Emissions',
  'human_readable_formula': 'sum_M_O(total_consumption(T,m,o)*estimated_italian_emission_factor(400))',
  'depends_on': ['operation', 'machine'],
  'parsable_computation_formula': 'A°sum°mo[S°*[ R°total_consumption°T°m°o° ; C°400°]]',
  'depends_on_other_kpi': ['total_consumption'],
  'superclasses': ['sustainability_kpi'],
  'entity_type': 'instance'},
 1)

>>> get_closest_object_properties('wrong_label')
({'label': 'testing_machine_2',
  'location': 'floor_2',
  'database_id': 'ast-pu7dfrxjf2ms',
  'superclasses': ['testing_machine'],
  'entity_type': 'instance'},
 0.2941176470588235)
</pre>

		<hr style="border: 1px solid #000000; margin: 50px auto;">
		
		<h3><code>add_kpi(superclass, label, description, unit_of_measure, parsable_computation_formula, 
            human_readable_formula=None, depends_on_machine=False, depends_on_operation=False)</code></h3>
		<p>
		  <strong>Description:</strong> Adds a new KPI to the ontology. 
		  This function validates that the KPI's label and superclass are unique and correctly defined. 
		  It then creates the KPI and associates the provided attributes, formulas, and dependencies.
		</p>

		<p><strong>Parameters:</strong></p>
		<ul>
		  <li><code>superclass</code> (str): The label of the superclass for the KPI.</li>
		  <li><code>label</code> (str): The unique label for the KPI.</li>
		  <li><code>description</code> (str): A text description of the KPI.</li>
		  <li><code>unit_of_measure</code> (str): The measurement unit for the KPI.</li>
		  <li><code>parsable_computation_formula</code> (str): A machine-readable formula for the KPI.</li>
		  <li><code>human_readable_formula</code> (str, optional): A user-friendly formula (default is the parsable formula).</li>
		  <li><code>depends_on_machine</code> (bool, optional): Whether the KPI depends on machines.</li>
		  <li><code>depends_on_operation</code> (bool, optional): Whether the KPI depends on operations.</li>
		</ul>

		<p><strong>Returns:</strong></p>
		<ul>
		  <li><code>None</code>: Prints errors or creates the KPI instance.</li>
		</ul>

		<h3>Notes</h3>
		<p>This function ensures that the KPI's label and superclass are unique within the ontology. It will also handle dependencies on machines and operations if specified.</p>

		<h3>Examples</h3>
		<pre>
>>> new_kpi_inputs = ['utilization_kpi', 
				'availability', 
				'Percentage of machine uptime in respect to machine downtime over each machine-operation pairs', 
				'%', 
				'S°*[ S°/[ A°sum°m[ R°time_sum°T°m°working° ] ; S°+[ A°sum°m[ R°time_sum°T°m°idle° ] ; A°sum°m[ R°time_sum°T°m°offline° ] ] ] ; C°100° ]',
				'(sum_M( time_sum(T,m,working)) / ( sum_M(time_sum(T,m,Idle)) + sum_M(time_sum(T,m,offline)) ) )*100',
				True,
				True]
>>> add_kpi(*new_kpi_inputs)
KPI availability successfully added to the ontology!

>>> add_kpi(*new_kpi_inputs)
KPI availability ALREADY EXISTS


</pre>

    </main>
</body>
</html>
